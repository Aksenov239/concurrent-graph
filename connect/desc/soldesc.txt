Решение за O(NlogN * СНМ).

Добавлять ребра мы умеем с помощью Disjoint Set Union.
Удалять мы не умеем и не будем.

Будем обрабатывать все запросы на отрезке [L..R) рекурсивно.
Когда обрабатываем отрезок [L..R), поддерживаем граф, в который добавлены
ребра из запросов [1..L), которые на [L..R) не придется удалять.
Также храним все ребра из [1..L), которые будут удалены на [L..R).

[L..R) = [L..M) + [M..R)
Обработаем сперва [L..M) затем [M..R)

Функция обрабатывающая отрезок [L..R) запросов в первую очередь за O(R-L)
добавляет в граф все ребра из [1..M), которые уже не будут удаляться.

Затем уходит в рекурсию.

Затем за O(R-L) откатываем структуру данных (систему неперсекающих множеств)
до прежнего состояния.

СНМ в данном случае работает не за O(1*), а за O(logN) (т.к. нам интересна 
не амортизированная оценка, а худший случай).
